<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PLOTTER</title>
  <style>
    body { margin:0; font-family: Arial, sans-serif; text-align:center; }
    canvas { background:green; display:block; margin:10px auto; touch-action:none; }
    #controls { margin:10px; }
    #welcomeBox { display:inline-block; padding:5px 10px; border-radius:5px; margin:10px; }
    #loginPopup {
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center;
      z-index:1000;
    }
    #loginBox { background:white; padding:20px; border-radius:10px; text-align:center; }
    #loginBox input { padding:5px; margin:10px 0; }
    #loginBox button { background:red; color:white; border:none; padding:8px 16px; cursor:pointer; border-radius:5px; }
  </style>
</head>
<body>
  <h2>PLOTTER <span id="welcomeBox"></span></h2>
  <div id="controls">
    <input type="text" id="pointInput" placeholder="Enter point e.g. -2,3">
    <button onclick="plotPointFromInput()">Plot</button>
    <label><input type="checkbox" id="intersectionCheck"> Intersection</label>
    <input type="range" id="zoomSlider" min="10" max="100" value="40">
  </div>
  <canvas id="graphCanvas" width="600" height="600"></canvas>

  <div id="loginPopup">
    <div id="loginBox">
      <h3>Login</h3>
      <input type="text" id="username" placeholder="Username">
      <br>
      <button onclick="confirmLogin()">Confirm</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const pointInput = document.getElementById('pointInput');
    const intersectionCheck = document.getElementById('intersectionCheck');
    const zoomSlider = document.getElementById('zoomSlider');

    let scale = parseInt(zoomSlider.value);
    let points = [];

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'green';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(canvas.width/2, 0);
      ctx.lineTo(canvas.width/2, canvas.height);
      ctx.moveTo(0, canvas.height/2);
      ctx.lineTo(canvas.width, canvas.height/2);
      ctx.stroke();

      ctx.fillStyle = 'black';
      ctx.font = '10px Arial';
      for (let x = -canvas.width/(2*scale); x <= canvas.width/(2*scale); x++) {
        const px = canvas.width/2 + x*scale;
        ctx.fillText(x, px, canvas.height/2 + 10);
      }
      for (let y = -canvas.height/(2*scale); y <= canvas.height/(2*scale); y++) {
        const py = canvas.height/2 - y*scale;
        ctx.fillText(y, canvas.width/2 + 5, py);
      }

      points.forEach(p => {
        ctx.beginPath();
        ctx.arc(canvas.width/2 + p.x*scale, canvas.height/2 - p.y*scale, 5, 0, 2*Math.PI);
        ctx.fillStyle = p.removed ? 'black' : 'red';
        ctx.fill();
      });

      if (intersectionCheck.checked && points.length > 1) {
        drawIntersections();
      }
    }

    function plotPoint(x, y) {
      points.push({x, y, removed:false});
      drawGraph();
    }

    function plotPointFromInput() {
      const val = pointInput.value.trim();
      if (!val) return;
      const [x, y] = val.split(',').map(Number);
      if (!isNaN(x) && !isNaN(y)) {
        plotPoint(x, y);
        pointInput.value = '';
      }
    }

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left - canvas.width/2)/scale;
      const y = (canvas.height/2 - (evt.clientY - rect.top))/scale;
      return {x, y};
    }

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left - canvas.width/2)/scale;
      const y = (canvas.height/2 - (touch.clientY - rect.top))/scale;
      return {x, y};
    }

    canvas.addEventListener('click', (e) => {
      const pos = getMousePos(e);
      plotPoint(Math.round(pos.x), Math.round(pos.y));
    });

    let lastTap = 0;
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        const pos = getTouchPos(e.touches[0]);
        if (tapLength < 300 && tapLength > 0) {
          toggleRemovePoint(Math.round(pos.x), Math.round(pos.y));
        } else {
          plotPoint(Math.round(pos.x), Math.round(pos.y));
        }
        lastTap = currentTime;
      }
    });

    // Pinch zoom handling
    let lastDistance = null;
    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (lastDistance) {
          if (distance > lastDistance) {
            scale = Math.min(scale + 1, 100);
          } else if (distance < lastDistance) {
            scale = Math.max(scale - 1, 10);
          }
          zoomSlider.value = scale;
          drawGraph();
        }
        lastDistance = distance;
      }
    });

    canvas.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) lastDistance = null;
    });

    canvas.addEventListener('dblclick', (e) => {
      const pos = getMousePos(e);
      toggleRemovePoint(Math.round(pos.x), Math.round(pos.y));
    });

    function toggleRemovePoint(x, y) {
      for (let p of points) {
        if (Math.abs(p.x - x) < 1 && Math.abs(p.y - y) < 1) {
          p.removed = true;
        }
      }
      drawGraph();
    }

    zoomSlider.addEventListener('input', () => {
      scale = parseInt(zoomSlider.value);
      drawGraph();
    });

    intersectionCheck.addEventListener('change', drawGraph);

    function drawIntersections() {
      let activePoints = points.filter(p => !p.removed);
      if (activePoints.length < 2) return;

      for (let i = 0; i < activePoints.length; i++) {
        let p1 = activePoints[i];
        let distances = activePoints.map((p2, j) => ({
          index:j,
          dist: Math.hypot(p1.x - p2.x, p1.y - p2.y)
        })).filter(d => d.index !== i);
        distances.sort((a,b) => a.dist - b.dist);

        let neighbors;
        if (activePoints.length <= 3) {
          neighbors = distances.slice(0,1);
        } else {
          neighbors = distances.slice(0,2);
        }

        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        neighbors.forEach(n => {
          let p2 = activePoints[n.index];
          ctx.moveTo(canvas.width/2 + p1.x*scale, canvas.height/2 - p1.y*scale);
          ctx.lineTo(canvas.width/2 + p2.x*scale, canvas.height/2 - p2.y*scale);
        });
        ctx.stroke();
      }
    }

    // Login system with localStorage
    const loginPopup = document.getElementById('loginPopup');
    const welcomeBox = document.getElementById('welcomeBox');

    function confirmLogin() {
      const username = document.getElementById('username').value.trim();
      if (!username) return;
      localStorage.setItem('plotterUser', username);
      setWelcome(username);
      loginPopup.style.display = 'none';
    }

    function setWelcome(username) {
      if (username === 'BhaveshOwner') {
        welcomeBox.textContent = 'Welcome, Owner';
      } else if (username === '@Mayank' || username === '@Rehan') {
        welcomeBox.textContent = 'Welcome, CEO of Toppers Group';
      } else {
        welcomeBox.textContent = 'Welcome, ' + username;
      }
      welcomeBox.style.background = 'red';
      welcomeBox.style.color = 'white';
    }

    window.onload = () => {
      const savedUser = localStorage.getItem('plotterUser');
      if (savedUser) {
        setWelcome(savedUser);
        loginPopup.style.display = 'none';
      }
      drawGraph();
    }
  </script>
</body>
</html>
